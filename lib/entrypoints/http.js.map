{"version":3,"sources":["../../src/server/entrypoints/http.js"],"names":["methodMapping","POST","GET","PUT","DELETE","handleRequest","request","response","method","service","then","result","url","pathname","indexOf","statusCode","write","end","catch","err","console","error","toString","parseBody","buffer","rawBody","Buffer","concat","headers","options","parse","contentType","Object","keys","decoder","charset","decodedBody","body","httpServer","host","log","href","query","on","chunk","push","listen"],"mappings":"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","file":"http.js","sourcesContent":["import { createServer } from 'http';\nimport querystring from 'querystring';\nimport { StringDecoder } from 'string_decoder';\nimport url from 'url';\nimport gateway from '../gateway';\nimport zlib from 'zlib';\n\nconst methodMapping = {\n  POST: 'create',\n  GET: 'read',\n  PUT: 'update',\n  DELETE: 'delete',\n};\n\n/**\n * Handle an incomming request\n * @param {*} request the request object\n * @param {*} response the response object\n * @returns {void}\n */\nfunction handleRequest(request, response) {\n  // parse method\n  const method = methodMapping[request.method];\n\n  // call the services\n  gateway.service(`entrypoint:${method}`, request, response).then((result) => {\n    // handle no response from server\n    if (!result) {\n      if (request.url.pathname.indexOf('.') === -1) {\n        request.url.pathname = '/index.html';\n        gateway.service('entrypoint:read', request, response);\n      } else {\n        // if it requested a file the file wasn't found\n        response.statusCode = 404;\n        response.write('Not Found');\n        response.end();\n      }\n    }\n  }).catch((err) => {\n    console.error(err);\n    response.statusCode = 500;\n    if (typeof err === 'object') {\n      err = err.toString();\n    }\n    response.write(err);\n    response.end();\n  });\n}\n\n/**\n * Parse any body send with te request\n * @param {*} request the request object\n * @param {*} response the response object\n * @param {array} buffer the buffer object\n * @returns {void}\n */\nfunction parseBody(request, response, buffer) {\n  request.rawBody = Buffer.concat(buffer);\n\n  if (request.headers['content-type']) {\n    const options = querystring.parse(request.headers['content-type'], ';');\n    const contentType = Object.keys(options)[0];\n    delete options[contentType];\n\n    switch (contentType) {\n      case 'application/x-www-form-urlencoded':\n        const decoder = new StringDecoder( options.charset || 'utf8');\n        const decodedBody = decoder.end(request.rawBody);\n        request.body = querystring.parse(decodedBody);\n        break;\n      // TODO implement 'multipart/form-data':\n      default:\n        response.statusCode = 415;\n        response.write('Unsupported Media Type');\n        response.end();\n    }\n  }\n}\n\nconst httpServer = createServer((request, response) => {\n  // parse url\n  request.url = url.parse(`http://${request.headers.host}${request.url}`);\n  console.log(request.url.href);\n  // parse querystring\n  request.query = querystring.parse(request.url.query);\n\n  const buffer = [];\n\n  request.on('data', (chunk) => {\n    buffer.push(chunk);\n  });\n  request.on('end', () => {\n    // parse the body\n    parseBody(request, response, buffer);\n\n    handleRequest(request, response);\n  });\n\n  // TODO turn the request and response into a more generic interface\n  // which would also work for websockets e.a.\n});\n\nhttpServer.listen(80);\n"]}